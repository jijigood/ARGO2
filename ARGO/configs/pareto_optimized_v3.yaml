# Pareto实验优化配置 V3 - 平滑Pareto边界
# ==========================================
# 目标：实现平滑的Pareto边界，避免二元崩溃
#
# 核心修复：
# - 确保 检索效率 > 推理效率，使θ_cont随μ平滑变化
# - 调整参数使不同μ值产生不同的策略（而非只有两种模式）
#
# 效率计算：
# - 检索效率 = E[delta_r] / c_r = p_s × delta_r / c_r
# - 推理效率 = delta_p / c_p
#
# 设计原则：
# 1. 检索效率 > 推理效率 → 低μ时偏好检索
# 2. 效率比例适中（~1.5-2x）→ 允许μ逐渐过渡
# 3. 成本参数合理 → 成本对策略有明显影响
# ==========================================

gpu:
  n_gpus: 8
  max_memory_per_gpu: 10
  default_gpu_ids: [4, 5, 6, 7]
  default_mode: "auto"

models:
  small:
    models:
      - "Qwen/Qwen2.5-1.5B-Instruct"
      - "Qwen/Qwen2.5-3B-Instruct"
    recommended_mode: "single"
    n_gpus_needed: 1

mdp:
  # 状态空间
  U_max: 1.0
  
  # ========================================
  # 核心修复参数 - 确保检索效率 > 推理效率
  # ========================================
  # 
  # 检索参数:
  delta_r: 0.25       # 检索进度增量 (增加到0.25)
  p_s: 0.75           # 检索成功概率 (增加到0.75)
  c_r: 0.15           # 检索成本
  
  # 推理参数:
  delta_p: 0.04       # 推理进度增量 (降低到0.04)
  c_p: 0.06           # 推理成本
  
  # ========================================
  # 效率分析
  # ========================================
  # 检索效率 = p_s × delta_r / c_r = 0.75 × 0.25 / 0.15 = 1.25
  # 推理效率 = delta_p / c_p = 0.04 / 0.06 = 0.667
  # 
  # 效率比 = 1.25 / 0.667 = 1.87 (检索效率是推理的1.87倍)
  # 
  # 预期行为：
  # - μ=0.0: θ_cont ≈ θ* (只用检索直到终止)
  # - μ=0.2: θ_cont ≈ 0.7 (检索到70%后开始推理)
  # - μ=0.5: θ_cont ≈ 0.4 (检索到40%后开始推理)
  # - μ=0.8: θ_cont ≈ 0.1 (少量检索后转推理)
  # - μ=1.0: θ_cont ≈ 0 (几乎只推理)
  
  # MDP求解参数
  mu: 0.5             # 默认值 (实验时会扫描)
  gamma: 0.98         # 折扣因子
  grid_size: 101      # U的离散化粒度
  
  # 质量函数
  quality_function: "linear"
  quality_k: 1.0
  
  # Reward Shaping
  reward_shaping:
    enabled: false
    k: 1.0

inference:
  batch_size: 4
  generation:
    max_new_tokens: 10
    temperature: 0.1
    do_sample: false
  dtype: "float16"

output:
  results_dir: "results/pareto_optimized_v3"
  save_full_results: true
  verbose: true
