O-RAN.WG10.OAM-Architecture-R003-v09.00
Technical Specification
O-RAN Operations and Maintenance Architecture
Copyright © 2023 by the O-RAN ALLIANCE e.V.
The copying or incorporation into any other work of part or all of the material available in this specification in any form without the prior written permission of O-RAN ALLIANCE e.V.  is prohibited, save that you may print or download extracts of the material of this specification for your personal use, or copy the material of this specification for the purpose of sending to individual third parties for their information provided that you acknowledge O-RAN ALLIANCE as the source of the material and that you inform the third party that these conditions apply to them and that they must comply with them.
O-RAN ALLIANCE e.V., Buschkauler Weg 27, 53347 Alfter, Germany
Register of Associations, Bonn VR 11238, VAT ID DE321720189
Contents
Foreword
This Technical Report (TR) has been produced by the O-RAN Alliance.
Modal verbs terminology
In the present document "shall", "shall not", "should", "should not", "may", "need not", "will", "will not", "can" and "cannot" are to be interpreted as described in clause 3.2 of the O-RAN Drafting Rules (Verbal forms for the expression of provisions).
"must" and "must not" are NOT allowed in O-RAN deliverables except when used in direct citation.
1	Introductory Material
1.1	Scope
The contents of the present document are subject to continuing work within O-RAN and may change following formal O-RAN approval. Should the O-RAN Alliance modify the contents of the present document, it will be re-released by O-RAN with an identifying change of version date and an increase in version number as follows:
version xx.yy.zz
where:
xx:	the first digit-group is incremented for all changes of substance, i.e. technical enhancements, corrections, updates, etc. (the initial approved document will have xx=01).  Always 2 digits with leading zero if needed.
yy:	the second digit-group is incremented when editorial only changes have been incorporated in the document. Always 2 digits with leading zero if needed.
zz:	the third digit-group included only in working versions of the document indicating incremental changes during the editing process. External versions never include the third digit-group.  Always 2 digits with leading zero if needed.
This document defines O-RAN OAM architecture and interface functions. The OAM architecture supports a variety of management network deployment models, including the model of management entities (NMS/EMS/MANO) connecting directly to NEs, and the indirect connection (e.g., M-Plane involved) model. A separate OAM interface document provides details of the functions and protocols conveyed over the interface, that include management functions, procedures, operations and corresponding solutions.
2	References
2.1	Normative References
References are either specific (identified by date of publication and/or edition number or version number) or non-specific. For specific references, only the cited version applies. For non-specific references, the latest version of the referenced document (including any amendments) applies.
NOTE:	While any hyperlinks included in this clause were valid at the time of publication, O-RAN cannot guarantee their long term validity.
The following referenced documents are necessary for the application of the present document.
O-RAN-WG4.MP.0: O-RAN Alliance Working Group 4 Management Plane Specification
O-RAN.WG10.O1-Interface: “O-RAN Operations and Maintenance Interface Specification”.
O-RAN.WG10.Information Model and Data Models: “O-RAN Information Model and Data Models Specification”
O-RAN.WG11-O-RAN-Security-Requirements-Specification: “O-RAN Security Requirements”
2.2	Informative references
References are either specific (identified by date of publication and/or edition number or version number) or non-specific. For specific references, only the cited version applies. For non-specific references, the latest version of the referenced document (including any amendments) applies.
NOTE:	While any hyperlinks included in this clause were valid at the time of publication, O-RAN cannot guarantee their long term validity.
The following referenced documents are not necessary for the application of the present document but they assist the user with regard to a particular subject area:
3GPP TR 21.905: “Vocabulary for 3GPP Specifications”
3GPP TS 28.622: "Telecommunication management; Generic Network Resource Model (NRM) Integration Reference Point (IRP); Information Service (IS)".
3GPP TS 28.532: Management and orchestration; Generic management services
3GPP TS 28.533: Management and orchestration; Architecture framework
3GPP TS 28.550: Management and orchestration; Performance assurance
ETSI GS NFV-IFA 005 V3.3.1, Network Functions Virtualisation (NFV) Release 3;Management and Orchestration;Or-Vi reference point - Interface and Information Model Specification
O-RAN White Paper: “O-RAN: Towards an Open and Smart RAN”, October 2018
O-RAN.WG6.ORC, “Cloudification and Orchestration Use Cases for O-RAN Virtualized RAN”
O-RAN-WG6.O2-GA&P: “O2 General Aspects and Principles”
O-RAN.WG1-O-RAN Architecture Description: “O-RAN Architecture Description”
O-RAN.WG3.RICARCH: “Near-Real-time RAN Intelligent Controller: Near-RT RIC Architecture”
RFC 6241, “Network Configuration Protocol (NETCONF)”, IETF, June 2011
O-RAN.WG5.MP.0, ”O1 Interface specification for O-DU”
3	Definition of terms, symbols and abbreviations
3.1	Terms
For the purposes of the present document, the terms and definitions given in 3GPP TR 21.905 [i.1] apply. A term defined in the present document takes precedence over the definition of the same term, if any, in 3GPP TR 21.905 [i.1].
infrastructure resources: Infrastructure resources as used here refer to a set of resources provided to a VNF [i.6] by its supporting O-Cloud.
Service Planning: The activity of a Service Operator around certifying a solution configuration for deployment into their network.
Service Provider: A network provider who is planning to deploy applications into their network.
Solution Provider: An application developer who delivers applications to Service Providers.
"SP" Exchange: Not a formal interface in terms of between systems. However, the structure and content of the exchange is defined such that a Solution Provider can deliver applications to a Service Provider for deployment.
3.2	Symbols
VOID
3.3	Abbreviations
For the purposes of the present document, the abbreviations given in 3GPP TR 21.905 [i.1] apply. An abbreviation defined in the present document takes precedence over the definition of the same abbreviation, if any, in 3GPP TR 21.905 [i.1].
FCAPS	Fault, Configuration, Accounting, Performance, Security
FOCOM	Federated O-Cloud Orchestration and Management
IOC	Information Object Class
MA	Managed Application
ME	Managed Element
MF	Managed Function
MnF	Management Function
MnS	Management Service
MMP	Meet-Me-Point
NAT	Network Address Translation
Near-RT RIC      O-RAN Near Real Time RAN Intelligent Controller
NFO	Network Function Orchestration
NFV 	Network Function Virtualization
NFVI	Network Function Virtualization Infrastructure
Non-RT RIC	O-RAN Non-Real Time RAN Intelligent Controller
O-CU-CP	O-RAN Central Unit – Control Plane.
O-CU-UP	O-RAN Central Unit – User Plane
O-DU	O-RAN Distributed Unit
O-RU	O-RAN Radio Unit
PCP	Port Control Protocol
PK	Primary Key
PNF 	Physical Network Function
SDLC	Software Development LifeCycle
SMO	Service Management and Orchestration
VNF 	Virtualized Network Function
UPNP	Universal Plug-N-Play
4	O-RAN Overview
4.1	Scope and Objectives
The O-RAN OAM Architecture identifies management services, managed functions and managed elements supported in O-RAN, including the interworking between service management and orchestration and other O-RAN components such as infrastructure management.  Requirements are derived from end-to-end OAM use cases, using the initial provisioning of O-RAN service across VNFs and PNFs as the primary use case.  The architecture identifies the interfaces between O-RAN Service Management and Orchestration and Managed Elements for different models and example deployment options.  It provides a description of the LifeCycle Management for applications delivered from a Solution Provider to a Service Provider/Network Operator.
4.2	End-to-End OAM Use Cases
4.2.1	O-RAN Provisioning Use Case
4.2.1.1	Basic Objective
In the O-RAN architecture, the radio side includes Near-RT RIC, O-CU-CP, O-CU-UP, O-DU, and O-RU Network Functions (NFs).  The management side is comprised of the Service Management and Orchestration Framework (and thus the Non-RT RIC). In the NFV environment, O-RAN Network Functions can also be implemented in a virtualized form, and thus include an Infrastructure layer (e.g., COTS/White Box/Peripheral hardware and virtualization layer) based on an O-Cloud.
The current use case focuses on O-RAN Network Function deployment rather than physical construction. According to the radio coverage requirements, operators may deploy the O-RAN NFs on dedicated physical resources and/or virtualized resources in a specific area.
This use case assumes that the O-RAN NFs are deployed based on a Network Design using Virtualized Network Functions (VNFs) for centralized functions and Physical Network Functions (PNFs) for functions closer to the customer, so that the sequence calls for deployment of VNFs for the Near-RT RIC, O-CU-CP and O-CU-UP first followed by PNFs for the O-DU and O-RU. Note: RF functions are always realized as PNFs but the O-DU can be realized as a PNF or VNF; this document uses PNF as an example to illustrate the associated OAM flows.
It is also assumed that secure network connectivity is already available between RAN components.
4.2.1.2	Entities/Resources Involved
To support the O-RAN network provisioning, the Service Management and Orchestration Framework needs to support the following capabilities:
O-RAN NF deployed in selected area
For non-virtualized parts, the Service Management and Orchestration Framework supports the deployment of PNFs on the target dedicated physical resources which satisfy the coverage requirements, with management through the O1 interface.
For VNFs, the Service Management and Orchestration Framework has the capability to interact with the O-Cloud to perform NF life cycle management, e.g. instantiate the VNF on the target infrastructure through the O2 interface (e.g., indicate the selected geo-location for each VNF to be instantiated, where close to the PNFs).
The Service Management and Orchestration Framework has the capability to consume the provisioning management service through the O1 interface to manage the configuration of the NF, details are defined in O-RAN.WG10.OAM Interface Specification [2].
O-RAN network provisioning
Based on the deployed NFs, the Service Management and Orchestration Framework configures the IP addressing, etc. in the PNFs and VNFs to support connectivity between them (this operation may also be performed during the instantiation steps).
Operators can operate and maintain the network dynamically through the O1 and/or O2 interface by means of:
Reconfiguration of the NFs
System update (usually refers to software management, without adding NFs) and system upgrade (the NFs can be added/removed/modified)
According to above, the Service Management and Orchestration Framework together with the O-Cloud implements the O-RAN NF deployment and provisioning, creating an O-RAN network to provide service to consumers.
4.2.1.3	Solutions
Table 4.2.1-1 shows the O-RAN provisioning procedures.
Table 4.2.1-1: O-RAN provisioning
Figure 4.2.1-1: O-RAN Provisioning Use Case
4.2.2	O-RAN Measurement Data Collection Use Case
4.2.2.1	Basic Objective
In this use case, the Non-RT RIC as the intelligent management center located in Service Management and Orchestration Framework determines that measurement data is needed and interacts with the SMO OAM Functions to collect measurement data from network for AI/ML training/inference/analyzing, and then generate optimization operations in order to improve the end-to-end user service experience and the network performance.
According to the Service Management and Orchestration Framework, to fulfill the Non-RT RIC requested data collection, the following capability should be supported by the SMO (framework):
The SMO should support the MnS component Type A (defined in [i.4])generation and the corresponding operation performing (defined in [i.3] and [i.5]), according to the measurement data collection request from the Non-RT RIC
The SMO (framework) should support the MnS component type C (defined in [i.4]) consumption such as the measurement data requested by the Non-RT RIC
The current use case focuses on the Non-RT RIC requested measurement data collection and consumption, the SMO should generate the PM Job and perform the PM Job control operations accordingly, and the SMO (framework) should support the measurement data consumption by the Non-RT RIC.
Notes:
In the O-RAN SMO framework, in order to avoid PM Job conflict, it is suggested that the SMO take the responsibility for generating the PM Job and performing the PM Job control related operations.
In this use case, the MnS producer of an O-RAN NF decides if the PM Job is acceptable or not, in other words, it is ultimately this MnS producer which decides whether the measurement data collection task can be established or not.
4.2.2.2	Entities/Resources Involved
Roles in the PM Job Control related operations:
The Non-RT RIC: PM Job initiator
The SMO (framework): measurement service component type A consumer
The MnF of the O-RAN NF: measurement service component type A producer
To fulfill the Non-RT RIC requested measurement data collection by the SMO on the O1/O2 interface, the information related to the collection task shall comply with clause 6.3 defined in [2].
The measurement data collection information provided by the Non-RT RIC should be converted into a PM Job, and any management operations to the data collection task requested by the Non-RT RIC should be converted into the O1/O2 interface supported PM Job control related management service operations by the SMO.
Roles in the NotifyFileReady subscribing:
SMO: management service component type A consumer (the referenceConsumer, as defined in [i.3])
MnF of the O-RAN NF: producer of notifications
Roles in the measurement data consumption:
SMO: management service component type C consumer
MnF of the NFs: producer of streaming data
File Server: storage the measurement data file
4.2.2.3	Solutions
4.2.2.3.1	Measurement Data Collection Creation
Table 4.2.2-1 shows the procedure of the Non-RT RIC requested measurement data collection task fulfilled by the SMO on the O1/O2 interface.
Table 4.2.2-1: Measurement Data Collection Creation
Figure 4.2.2-1: Measurement Data Collection Creation
4.2.2.3.2	Measurement Data File Consumption
With the performance data file reporting method:
The measurement data file may be stored in a file server, and the path should be contained in the NotifyFileReady
Once the measurement data file has been prepared, the MnF of the O-CU-CP instance shall report the notification NotifyFileReady to the SMO
Table 4.2.2-2 shows the measurement data file consumption.
Table 4.2.2-2: Measurement Data File Ready Report
Figure 4.2.2-2: Measurement Data File Consumption
4.2.2.3.2	Measurement Streaming Data Consumption
With the streaming reporting method:
The consumer related information was taken to the producer in the operation of performance data collection creation.
The performance data streaming service producer shall establish streaming connection(s) to the consumer, in this use case, the MnF of the O-CU-CP acts as the performance data streaming service producer and the SMO as the consumer.
The MnF of the O-CU-CP shall send measured data on the established connection(s).
The table 4.2.2-3 shows the streaming connection(s) establishment and streaming data consumption.
Table 4.2.2-3: Measurement Streaming Data Consumption
Figure 4.2.2-3: Measurement Streaming Data Consumption
4.2.3	O-RAN Configuration
4.2.3.1 	Basic Objective
The objective of the use case is to provide the ability for the SMO to configure an O-RAN NF and to receive Configuration Management (CM) notifications from the MnF of the O-RAN NF.  The Configure O-RAN NF Use Case in this clause shows how O-RAN uses NETCONF as specified in the O1 Interface Specification [2] to configure O-RAN NFs.
4.2.3.2		Entities/Resources Involved
Roles in the Provisioning Use Case:
SMO is the Provisioning MnS Consumer
MnF of the O-RAN NF is the Provisioning MnS Provider
4.2.3.3		Configure O-RAN NF Use Case
The Configure O-RAN NF Use Case illustrates the sequence of NETCONF commands and Provisioning MnS operations, as specified in the O1 Interface Specification [2], to configure a NF.
Before issuing any NETCONF commands, the NETCONF session shall be established.  Before changing the configuration of a NF, the appropriate target data store in the associated MnF should be locked to prevent other NETCONF clients, non-NETCONF clients, and human users from interfering with the configuration changes.  Note that locking the data store is optional and is at the discretion of the SMO/operator.
Configuration changes are made using the Create Managed Object Instance operation, Delete Managed Object Instance operation or Modify Managed Object Instance Attributes operation as specified in O-RAN O1 Interface Specification [2].  If desired, SMO may first read the current NF configuration using the Read Managed Object Instance Attributes operation as specified in O-RAN O1 Interface Specification [2], before modifying the configuration, in order to ensure that the SMO is synchronized with the current NF configuration. Note that reading the current configuration is optional and is at the discretion of the SMO/operator.  If the changes are made in a candidate data store, SMO shall commit the changes to the running data store to make them effective.
If the SMO wishes to receive CM notifications, SMO shall subscribe to CM notifications using the Subscription Control operation, as specified in O-RAN O1 Interface Specification [2].
Multiple provisioning operations can be executed in sequence, one at a time, under the same lock session.  When the SMO has finished sending all the commands that modify the configuration of the data store, the SMO should unlock the target data store so that other clients can make changes.  Note that unlocking the data store is optional and is at the discretion of the SMO/operator.
Finally, if the SMO has no more provisioning operations to perform at this time, SMO can terminate the NETCONF session.  Note that terminating the NETCONF session is optional and is at the discretion of the SMO/operator.
Table 4.2.3-1 shows the End to End Use Case for the SMO to configure a NF.
Table 4.2.3-1: Configure NF
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
box “Service Management & \nOrchestration Framework” #gold
Participant “OAM Functions” as SMO
end box
box "O-RAN Managed Element"#lightpink
Participant “ME” as ME
end box
Opt If NETCONF session is not established
note over SMO, ME #lightblue
<<O1>> NETCONF Session Establishment
endnote
End
Opt
note over SMO, ME #lightblue
<<O1>> NETCONF Lock Data Store
endnote
End
== SMO configures the ME ==
Opt If SMO desires
note over SMO, ME #lightblue
<<O1>> Read MOI Attributes
Endnote
End
Loop until all commands are sent
note over SMO, ME #lightblue
<<O1>> Delete MOI and/or Create MOI and/or Modify MOI Attributes
Endnote
Opt If target DB is candidate
note over SMO, ME #lightblue
<<O1>> NETCONF Commit
Endnote
End Opt
Opt If SMO has subscribed to CM notifications
note over SMO, ME #lightblue
<<O1>> HTTPS CM notification
Endnote
End Opt
End Loop
== Configuration changes complete ==
Opt
note over SMO, ME #lightblue
<<O1>> NETCONF Unlock Data Store
endnote
End
Opt If SMO has no more NETCONF operations to perform
note over SMO, ME #lightblue
<<O1>> NETCONF Session Termination
endnote
End
@enduml
Figure 4.2.3-1: Configure NF
5	OAM Architecture
5.1	Architectural Principles
The following clause provides architecture principles guiding the support of OAM in the O-RAN architecture. Common OAM functions should be supported through a common set of OAM interface protocols across the different components of the O-RAN architecture.
Management Services should, to the degree possible, align with existing standards specifications:
3GPP 5G Specifications for management interfaces
ETSI NFV Specifications for life cycle management
O-RAN Front Haul M-Plane [1]
O-RAN OAM specifications should refer to the 3GPP and ETSI specs and not replicate them here.  O-RAN OAM specifications shall identify needed extensions to support O-RAN and exceptions which cannot be supported.  It is the goal of O-RAN to drive any needed extensions into standards to maintain alignment between O-RAN and existing standards.
5.1.1	Alarm Dictionary Overview
Entities that are part of an O-RAN deployment can emit alarm notifications to the SMO to indicate adverse conditions on the entity that the SMO needs to be aware of and potentially take corrective actions for.  Entities typically emit alarm notifications on one OAM interface (O2-IMS or O2-DMS for Cloud, O1 for the MnF(s) of O-RAN NFsother than the O-RU , Open FH M-Plane for O-RU).
The Alarm Dictionary allows the SMO to become aware of the alarming capabilities of the O-RAN entity. The alarm dictionary provided by the vendors will be provided in a common, machine readable format.  This will allow the service provider to have a common way of querying or displaying the information they need to help them determine what actions to take when an alarm occurs.  The alarm dictionary contains an entry for each alarm that the product emits to the manager. Alarm notification formats are/will be standardized on these interfaces and will contain instance specific information about the condition triggering the alarm such as: an identifier for the alarm, what instance of the entity is alarming and to the degree possible pinpointing where the problem is originating from.  Much of the information in the notification will be specific to this instance of the problem occurring.  Some information associated with an alarm can be static (such as the alarm name or description) and not dependent upon the instance of the alarm sent in the alarm notification.  Typically, this information is descriptive in nature such as providing a detailed description of why an alarm is raised, what the alarming condition means and its impact on the system and vendor suggested repair actions.  To be efficient in transmission, O-RAN expects that vendors provide an alarm dictionary that contains this static information in a machine-readable format which the service provider can consult to determine what actions may be taken when a particular alarm notification is raised.
The alarm dictionary is delivered to the manager as part of:
Onboarding package when a software delivery of an O-RAN NF or xApp/rApp is made.
Registration when updates are made to O-Cloud entities
The alarm dictionary is stored in a repository where the SMO can access it upon reception of an alarm notification to display the information associated with an alarm to a human user to support determining what corrective action to take.  The information in the alarm dictionary definitions is not delivered within the alarm notification.
5.1.2	Alarm Dictionary Association with O-RAN Entities and Content
Each entity emitting alarms has an alarm dictionary version associated with each of its software versions so the SMO can determine which alarm dictionary should be consulted when the entity emits an alarm.  Typically, the alarm dictionary will be associated with one or more versions of a delivery of an entity.  The alarm dictionary version changes only when an alarm is added to the dictionary, has an element in the dictionary change, or if an alarm is no longer supported.  For this reason, a vendor may associate several deliveries of product with the same version of an alarm dictionary.
A vendor shall update the alarm dictionary whenever an alarm is added, deleted, or modified in the product software and provide a “last change” indicator for each alarm entry to make it easy for an Operator to know what has changed from one version of the alarm dictionary to another.
The alarm dictionary provides information about each alarm/alarm family that an O-RAN entity emits to the manager; information that is important for understanding and processing the alarm but is not provided as part of the alarm notification itself.  The entries are formatted according to a common Alarm Dictionary schema that is applicable to all O-RAN alarms over any OAM interface (O1, O2, Fronthaul, Transport).
The alarm dictionary consists of:
Header – information common for all alarm entries in this version of the Alarm Dictionary
Alarm Entries – one per alarm containing alarm-specific information
Details shall be as defined in the O-RAN IM/DM specification [3].
5.2	Architecture Requirements
Defines the Architecture requirements applicable to the O-RAN reference architecture.  Architecture requirements are derived from Use Cases to be supported and define the functional needs the architecture aims to satisfy.
5.2.1	Functional Requirements
5.2.2	Non-Functional Requirements
5.2.3	Security Requirements
Note: more detailed requirements for security are  addressed in [4].
5.3	Reference Architecture
The reference architecture defines a set of basic architectural building blocks – management services provided by the Management Function(s) of each O-RAN NF– for the O-RAN management domain.
5.3.1	Architectural Building Blocks
5.3.1.1	Management Services
O-RAN Management Services (MnS) offer capabilities to manage and orchestrate O-RAN Network Functions.   Management Functions of O-RAN NFs expose their management services to managers.  Managers consume the management services.
Examples of Management Services supported by O-RAN include:
Provisioning
Fault Supervision
Performance Assurance
Trace Management
File Management
Software Management
Communication Surveillance
Startup and Registration of a Physical Network Function (PNF)
Instantiation and Termination of a Virtualized Network Function (VNF)
Scaling Management Services for VNF
The definitions of supported management services and their APIs are specified in the OAM O1 Interface specification [2].
5.3.1.2	Managed Elements
The definition of a Managed Element (ME) is given in 3GPP TS 28.622 [i.2] clause 4.3.3.  The ME is an IOC that is used in the O-RAN Information Model [3].
5.3.1.3	Managed Functions and Network Functions
The definition of a Managed Function (MF) is given in 3GPP TS 28.622 [i.2] clause 4.3.4.  The MF is an abstract IOC that can be used to represent the management data of an O-RAN NF in the O-RAN Information Model [3].
O-RAN NFs include:
Near-Real-Time Radio Intelligent Controller (Near-RT RIC)
O-RAN Central Unit – Control Plane (O-CU-CP)
O-RAN Central Unit – User Plane (O-CU-UP)
O-RAN Distributed Unit (O-DU)
O-RAN Radio Unit (O-RU)
5.3.1.4	Managed Applications
ManagedApplication: This Information Object Class (IOC) represents a software application that may be independently tested and separately deployed from its containing ManagedFunction instance. The containing ManagedFunction instance mediates the management service for the Managed Application. A ManagedFunction instance may have zero or more Managed Application instances.
The xApp is defined in [i.11].  Management of the xApp shall comply with the following principles:
The O1 interface terminates on the Near-RT RIC platform, the Near-RT RIC platform delegates the management of xApps
An xApp may be provided by a third party, it is decoupled from the O-RAN platform on which it is running.
In order to model a variety of different types of xApps, it is necessary to extend common features of a parent Class, and the specific xApp IOC may inherit from its parent Class.
According to above principles, modeling to the xApp may be described as the following:
The xApp IOC represents the management aspects of the xApp
The xApp IOC inherits from ManagedApplication and may extend specific attributes.
The details of the MA are specified in the O-RAN Information Model specification [3].
5.3.1.5	Service Management and Orchestration Framework
The Service Management and Orchestration Framework is responsible for the management and orchestration of the NFs under its span of control.  The framework can for example be implemented as a third-party Network Management System (NMS) or orchestration platform.
The Service Management and Orchestration Framework shall provide an integration fabric and data services for the MnFs of the O-RAN NFs.  The integration fabric enables interoperation and communication between the SMO and the various MnFs within the O-RAN domain.  Data services provide efficient data collection, storage and movement capabilities for the MnFs.  In order to implement multiple OAM architecture options together with RAN service modeling, the modeling of different OAM deployment options and OAM services (integration fabric etc.) shall be supported by the SMO.
5.3.1.6	Non-Real Time Radio Intelligent Controller
The Non-RT RIC is a part of the Service Management & Orchestration Framework and communicates to the Near-RT RIC using the A1 interface. [i.7]
Non-RT control functionality (> 1s) and near-Real Time (near-RT) control functions (< 1s) are decoupled in the RIC. Non-RT functions include service and policy management, RAN analytics and model-training for some of the near-RT RIC functionality, and non-RT RIC optimization.
5.3.1.7	Control Loop Support
O-RAN defines 3 control loops with different latency bands [i.7]. These loops are not hierarchical but instead run in parallel. This does not mean that an NF with an inner loop will not generate its own event as result of an inner loop failure, but it will not simply propagate the lower level event received by the inner loop. The three loops are defined as:
Loop 1: In the O-DU for per TTI/msec resource scheduling (<10 millisecond)
Loop 2: In the Near-RT RIC and O-CU for resource optimization (10 milliseconds to 1 second)
Loop 3: In the Service Management and Orchestration Framework for ML Training, Trending, Orchestration (> 1 second)
5.3.2	Basic OAM Architecture
Figure 5.3.2-0-1 O-RAN Logical Architecture
Figure 5.3.2-1 shows the overall O-RAN Logical Architecture, as defined in [i.15].  The O1 interface identified in the O-RAN Architecture Description is used for OAM functions between the O-RAN Service Management and Orchestration Framework and the O-RAN Network Functions (with the exception of the O-RU). The Open FH M-plane is used for OAM functions between O-RAN Service Management and Orchestration Framework and the O-RU when the O-RU is managed using the hybrid management model.   Note: the figure uses 5G terminology, however the same principles will apply for LTE/4G.  The O-RAN Architecture also includes the O2 interface for management of the O-Cloud, which has different requirements from the O1 interface and is defined in [i.9].
The O1 OAM Interface includes implementation of Fault, Configuration, Accounting, Performance, Security (FCAPS) functions, File management and Software management functions for O-RAN Network Functions. For details of the management services supported by O1, see [2].
The O2 OAM Interface enables the management of O-Cloud infrastructures and the deployment life cycle management of O-RAN cloudified NFs that run on an O-Cloud.  For details of the functions supported by O2, see [i.9].
Open FH M-plane includes implementation of Fault, Configuration, Accounting, Performance, Security (FCAPS) functions, File management and Software management functions for O-RU. It also specifies the carrier management aspects and is used between O-DU and O-RU.
5.3.3	O-RU Management Models and Managed Deployment Options
This clause describes some of the possible O-RU management models, providing a high level description of the models.  O-RAN supports multiple deployment options. Adoption of a single O-RU management model or managed deployment option is not required in the O-RAN OAM Architecture. Multiple combinations of deployments may be supported in a network.
5.3.3.1	Flat Management Architecture Model
In the flat model, all entities/nodes are managed directly by the SMO.
5.3.3.2	Hierarchical Management Architecture Model
In the hierarchical model, all entities/nodes except for O-RUs are managed directly by the SMO, but the O-RU is managed directly by the O-DU (and indirectly by the SMO).  The WG4 Fronthaul M-Plane Specification [1] specifies the details of the use of the hierarchical model for the O-RAN O-RU.  The WG5 O1 Interface specification for O-DU [i.13] specifies the hierarchical management of the O-RU through the O-DU.
5.3.3.3	Hybrid Management Architecture Model
In the hybrid model, all entities/nodes except for O-RUs are managed directly by the SMO.  The O-RU is partially managed by the SMO (for FCAPS support) and partially managed by the O-DU. Details of the hybrid model for the O-RU including privilege division between SMO and O-DU can be found in the WG4 Fronthaul M-Plane Specification [1].
5.3.3.4	Example Managed Deployment Options
O-RAN also supports multiple deployment options. The O-RAN Architecture document [i.10] has an informative Annex A which provides several examples of O-RAN deployments.  The choice of deployment option is at the discretion of the service provider.
5.3.4	Network Functions Deployed behind a NAT
Service Providers prefer to not deploy Network Functions behind a NAT, but there are cases where this cannot be avoided, for example:
exhaustion of public Ipv4 addresses
deployment in large complexes not owned by the Service Provider (Apartments, Sports Venues etc.)
connections via third-party networks using a NAT
When a Service Provider deploys NFs behind a NAT it is critical that they are able to retain full management control of these entities.
Figure 5.3.4.1 O-RAN NFs behind a NAT
Four methods of providing the O-RAN SMO with the ability to address a NF behind a NAT and identify data received for a NF behind a NAT are recommended in priority order:
Use of IPv6 as Backhaul transport where possible, eliminating the need for a NAT due to exhaustion of public IPv4 addresses
Use of persistent VPN tunnels (e.g., IPSec) toward a VPN concentrator (gateway) located outside of network with the NAT.  The NF is then accessible through the established tunnel.
Use of standard protocol (UPNP or PCP) to establish a port-forwarding rule at the firewall and automatically assign itself a port.
Service Provider manually configures the firewall to assign a port to an entity that resides within the protected network.
6	Application Lifecycle Management (LCM)
This chapter describes Lifecycle Management of applications that are developed by a Solution Provider and delivered to a Service Provider or Network Operator for deployment in O-RAN.  The chapter’s current focus is on LCM of rApps and xApps, as defined in [i.10].
Lifecycle Management follows the basic models of a Software Development Lifecycle by defining the transitional information from one state to another. There are several Software Development Life Cycle (SDLC) definitions. For the purposes of discussion this document generally follows a 7-state model as shown in Figure 6-1. Some states may also include activities that align with other states. However, this level of detail is not depicted here in order to introduce those details later in the document.
A Service Provider or Network Operator has needs which are fulfilled by a Solution Provider. Once the Solution Provider delivers the application it is validated in a test environment prior to giving to operations to deploy.  Usage of the deployed application may result in changes to configuration by the Service Provider or may be feedback to Solution Providers to evolve the capabilities of the network and/or its management.
Although applications may come in many forms the delivery from the Solution Provider to the Service Provider needs to be done in a standardized manner. The seven steps defined in the SDLC are high level. Each may break down into a set of finer grain steps.
6.1	Scope
The end-to-end lifecycle involves two entities, the Solution Provider and the Service Provider. The Solution Provider provides applications for the Service Provider to use in their network. The working flow may be summarized as three phases: Development, Onboarding and Operations, as shown in Figure 6.1-2.
Figure 6.1-2 Application Lifecycle Phases
These applications should be onboarded in a common manner, regardless of how they are deployed. This clause of the specification focuses on the data that is included in the App Package as it is exchanged between the Solution Provider and the Service Provider. This exchange is referred to as the “SP” exchange. This is not a formal interface between systems and therefore is not denoted as other O-RAN interfaces are. Care is given as not to put implementation or tooling mandates on either the Solution Provider in their development of the application, or the Service Provider in the aspect of training or deploying the application. Aspects of the lifecycle across both parties are introduced. However, not all aspects are discussed. Instead the focus is on those activities that affect the data contained in the SP Exchange.  Later in this document the term “Service Planning” is used to represent activities internal to the Service Provider. This is not the same as the “SP Exchange” used to describe the data passed from the Solution Provider to the Service Provider. The method of the SP Exchange is not defined in this document. It is sometimes referred to as the “Marketplace”. The marketplace may be implemented by either the solution provider, the service provider, or an external entity to both. The Marketplace simply represents an exchange between entities which may be done by electronic means or physical media.
The App Development may provide application solutions with or without AI/ML models, while “App Onboard” and “App Operate” are responsible for application onboarding and operations. The application development may be completed in the environment provided by the Service Provider to provide additional privacy and security for the Service Provider.
Applications may or may not utilize AI/ML models. Therefore, although the Model Information may be optional in the App Package, data exchange in the Application Package for applications utilizing AI/ML models is also included.
6.1.1	Application Package Model
The following UML® diagram illustrates the high-level composition of the Application Package (AppPackage). An Application Package is the basic unit exchanged between the Solution Provider and Service Provider. The attributes of the entities in the diagram are representative.
NOTE: UML is a registered trademarks/service mark of the Object Management Group, in the United States and other countries. O-RAN is not affiliated with, endorsed, or sponsored by the Object Management Group.
@startuml
hide empty members
hide circle
Class AppPackage #Cyan
Class ManagementDescriptor #Gold
Class DeploymentDescriptor #LightSkyBlue
Class MLModelDescriptor #Pink
RTEDescriptor : May Have
@enduml
Figure 6.1-3: Application Package High Level Model
The following modifiers can be pre-pended to Model Elements to indicate context:
“Solution”	The version of the element as defined by the Solution Provider
“Onboarded”	The initial version of the catalogued elements created during onboarding.
“Catalogue”	Subsequent versions of the catalogued package or its elements which may have been adjusted by the Service Provider.
The AppPackage contains the DeploymentDescriptor and the ManagementDescriptor. An optional MLModelDescriptor is supplied for an application employing ML technology.
The DeploymentDescriptor describes the deployment options for the application that have been validated by the Solution Provider.  It includes one or more DeploymentItems describing the requirements for O-Cloud deployment of the application.  The DeploymentDescriptor and DeploymentItem are consumed by the SMO/NFO.
The ManagementDescriptor describes the application contained in the AppPackage.  It contains one or more ComponentDescriptors describing the components to be deployed as part of the application as well as elements used for FCAPS functions for the AppPackage such as an AlarmDictionary, ConfigurationModel, SecurityDescriptor, etc.  The ManagementDescriptor and its components are consumed by the SMO/FOCOM.  Note: Security requirements in general for O-RAN shall follow the requirements defined in [4].
ML Models may be pre-trained by the Solution Provider and therefore provide initial Training History. The Service Provider may also train the model or retrain the model with a more specialized data set, this is called specialization. The Training History provides the mechanism to record all training and subsequent specializations applied to that training through the Training History.
An example of specialization is a ML Model created to predict the flow of traffic volumes. This algorithm can be generally trained to follow road patterns for devices with a velocity greater than 20 miles per hour. This training may be done by the Solution Provider on a generalized or open data set and recorded in the MLModelDescriptor. After onboarding the Service Provider may provide specialized training for dense urban traffic patterns which don’t always follow the roads due to periodic traffic congestion This would be an additional Training History record added by the Service Provider and referenced as specialization in the Catalogue Training History. Further refinement may also be applied for specific cities such as New York, Los Angeles, or San Francisco which would now add 3 specializations Catalogue Training History records relating to the dense urban Catalogue Training History which is a specialization if the Onboarded Training History.
Once a Catalogue DeploymentDescriptor is validated as safe for use in operations it is published to a runtime environment as a Published DeploymentDescriptor. Runtime instance data may be applied to the Published DeploymentDescriptor. Applications deployed as part of this activity are called App Instances. An App Instance running in the Non-RT RIC Runtime can be referred to as an rApp instance.  An App Instance running in the near-RT RIC Runtime can be referred to as an xApp instance. An App Instance running in a training environment is referred to as a Training App instance.
Diagramming Legend
The legend depicted in Figure 6.1-4 is used across all lifecycle diagrams in this clause and is shown once so it is not required on every diagram. Bolded text on a diagram is an item identified as requiring further discussion later in the document. Text in Italics are items identified for completeness but not requiring further discussion. Meet-Me-Points (MMPs) are places where a major aspect of the lifecycle interchanges. Data may be exchanged through these MMPs but the exact mechanism of the exchange is outside the scope of this document. Destination or Decision points are color coded according to their user community. Destination or Decision points are not a contributing factor to the data demands of the “SP” Exchange and are therefore not named. Instead the actions or conditions that are used as a transition between points are named as the items of interest.
Figure 6.1-4: Life Cycle Diagram Legend
6.1.2	App Development Lifecycles
In the App Development Lifecycle only two aspects are defined, the Solution AppPackage Lifecycle and the Solution App Lifecycle.
6.1.2.1	Solution App Lifecycle
The Development Lifecycle steps related to the Solution App are shown below in Figure 6.1-6.
Figure 6.1-5: Solution App Development Lifecycle
Customer feedback can consist of use case requirements, feature requests, defect notifications, or a variety of other comments. These feed the development cycle to develop new application or enhance existing ones. Requirements are usually identified and sent to developers to implement. The outcome of the build process is the container images built using SDKs for their intended deployments. If the application is AI/ML enabled, then the training action is done. The training may happen with synthetic data or with data provided by Service Providers. Information on the training performed is included in the Solution Training History. The completed Solution App is stored in a development repository.
6.1.2.2	Solution AppPackage Lifecycle
The Development Lifecycle steps related the Solution AppPackage are shown below in Figure 6.1-6.
Figure 6.1-6: Solution AppPackage App Development Lifecycle
The Solution AppPackage is used to convey the Solution App through the onboarding process to the Service Provider. It begins by pulling the App out of its repository and placing it in the package as mandated by the exchange requirements. Next security is applied such that the Service Provider can ensure that an Onboarded AppPackage did in fact come from the expected Solution Provider. The secure package, Solution AppPackage, is then delivered to the Service Provider for onboarding.
6.1.3	App Onboarding Lifecycles
The App Onboarding phase deals with establishing configuration, policies, measurements, and required analytics.
The App Onboarding Phase is involved with both AppPackages and Apps, each with its own steps and associated actions.  These are treated separately below.
6.1.3.1	Onboarded AppPackage Lifecycles
The Service Design steps associated with an Onboarded AppPackage are shown below:
Figure 6.1-7: Onboarded AppPackage Service Provider Configuration Lifecycle
An AppPackage is onboarded from the exchange, and its content verified.  If valid, its contents (the App) are unpacked and the Onboarded AppPackage and associated Onboarded App are catalogued.  If invalid, the Service Provider may provide AppPackage-level feedback to the Solution Provider via the Marketplace.
6.1.3.2	Onboarded App Lifecycles
The App Onboarding Phase for Onboarded Apps is split between normal processing for all applications, named “Configuration”, and the lifecycle for “Training” Apps with included AI/ML Models. Workflow can interchange between these cycles iteratively.  Each of these is treated separately below.
Note: The Run Time Library shown in the clauses below models a location where apps/Artifacts can be identified as ready for future deployment. It is not intended to imply any particular method of implementation of the SMO.
6.1.3.2.1	Onboarded App Certification Lifecycle
The Service Operator Certification steps associated with an Onboarded App are shown below:
Figure 6.1-8 Onboarded App Service Provider Certification Lifecycle
Onboarded Apps are made visible in the SMO environment when published into the catalogue. Each recommended configuration of the App is certified prior to publication to a runtime library. If Certification fails, then Service Planning determines the next course of action.
Service Planning aggregates “fix” requests from Configuration which may be passed back to the Solution Provider (at the AppPackage level) as feedback across the SP interface of the Marketplace Exchange.   This exchange also aggregates “change” requests from Configuration or Operations and determines if the request is for additional development (a “feature” request) or additional training (a “training” request).  The former would be aggregated and passed back to the Solution Provider via the SP interface as described above for “fix” requests.  For the latter, the Service Design: Training lifecycle would ensue.
If the Onboarded App requires AI/ML training, then a request through Service Planning is used to train the model. When the “Specialized App “ is returned, like non-ML Onboarded Apps it is catalogued and scheduled for certification. Once certified the App is distributed as a Published App to a Run Time Library. From there operations can deploy as either a management (rApp) or network application instance (xApp).
6.1.3.2.2	App Training Lifecycle
The Service Operator Training Lifecycle associated with a Training App is shown below:
Figure 6.1-9: Training App  Service Provider Training Lifecycle
When a training request is received then resources within the training environment are scheduled for the application. Data is collected and groomed for training after which a training iteration is executed. At the end of the training cycle a test set is applied to the model and accuracy is calculated. If the test fails or other metadata indicates more training iterations are required, then the cycle repeats. Once the model is adequately trained it is promoted and sent back to service planning for continuation in another lifecycle.
Inside the “Training Lifecycle” the process may require multiple iterations of training before being returned to the Service Planning MMP.
The iteration count is included in the specialization metadata information.
6.1.4	App Operation Lifecycles
There can be many runtime environments in the service providers’ network. Some can be production while others can be for non-production execution, such as offline training and lab certification. This document focuses on the runtime aspects of rApps, which execute within the Non-RT RIC as part of the SMO, and xApps, which execute in the near-RT RIC as part of the RAN. Although they have the same lifecycle steps the data demands due to their operational environment are different and therefore are independently addressed.
6.1.4.1	App Instance Lifecycles
Figure 6.1-10: Service Provider Runtime Lifecycles
After the App Instance is created through a deploy operation it is monitored. As monitoring reports the health and workload of the application it is scaled up and down based on demand. Based on monitoring result, a series of operation and management functions are triggered, such as alert management, event management, incident management and further analysis. The analysis results can provide guidance for further actions such as termination, healing and scaling. Finally, when its job is completed, the instance is terminated. While in operation the service provider may discover defects, performance issues, or identify new features that would be beneficial. Such issue or change request is communicated to the Service planning where the Application can be retrained or updated. The information may also be sent via the Service Planning to the Solution Provider as feedback.
Operations determine when an application is deployed, or undeployed. Since applications are atomic, the update process is an orchestrated process of deploy and terminate. It is possible for two versions to be active at the same time, but care should be given not to provide overlapping scopes to the application instances, otherwise they may give differing directives to the network in a random order. This can cause a destabilization of the network.
6.2	Common Application Lifecycle Conclusions
The initial conclusion of Common Application Lifecycle procedures is that there is a formalized exchange between the Solution Provider and the Service Provider, the “SP Exchange”. The SP Exchange consists of data describing the package and its security. The package also contains information regarding Deployment Configurations, Application Types, Deployable Components, and potentially ML Models. Further details regarding the composition of these areas are defined through analysis of the Actions identified in clause 6.1 as an action requiring further analysis (Bolded). O-RAN use cases for App Operation Lifecycle actions beyond “Deploy” have not been specified. Therefore, the analysis of the App Operation Lifecycles has been limited to the “Deploy” action.
The analysis consists of identifying the actors within the LCM which need information. Each Information Object is then analyzed for the Actions identified above and what is needed by each actor is identified. The actor information requirements are then be coalesced into artifacts such that each artifact is only be consumed by one actor. This maintains a separation of concern regarding artifact composition for different consumers.
6.2.1	Information Consumers
The following actors are used in the analysis as consumers of information. The CNAD is unique in that it is also the producer of all the artifacts used to convey the information. However, since this is a basic premise it is not used in the analysis to describe its role in artifact generation.
6.2.2	Solution SW Package Lifecycle
The Solution SW package lifecycle deals with the Solution Provider creating a secure package that can be delivered to a Service Operator for onboarding. This largely deals with the addition of all the artifacts of the software into a library and then adding security around the files and the package. Annex clause C.1 describes the processing of the artifacts into the package.
6.2.2.1	Functional Requirements
6.2.3	Onboarded SW Package Lifecycles
The Onboarded SW Package Lifecycles deal with the importing of an Application Package by first verifying its authenticity and then verifying is consistency. Assuming the package passes those tests the contained artifacts are extracted from the package and added to the SMO catalogue. Annex clause C.2 describes the process of cataloguing the artifacts of the package.
6.2.3.1	Functional Requirements
6.2.4	Onboarded ManagementDescriptor Certification Lifecycle
The Onboarded ManagementDescriptor Certification Lifecycle entails certifying deployment options prior to utilization in a specific runtime environment. The SMO initiates the fine tuning of such an App for this deployment option. This process may be iterative and the SMO identifies each refinement of the App and certifies the refinements results in the App being suitable for inclusion in the run time library for deployment. Annex clause C.3 describes the process of certify a deployment option of the package.
6.2.4.1	Functional Requirements
6.2.5	Application Training Lifecycle
The Application Training Lifecycle deals with the training of an AI/ML Model that was included as part of a deployment option in an application package. The model is trained, and the resultant deployment is returned as a new version of the application. Annex clause C.4 describes the process of training an application deployment option which contains one or more ML Models.
6.2.5.1	Functional Requirements
Note 1: This requirement is overarching and generalized in nature. Specific requirements for rApps or xApps as specified by other Work Groups shall supersede this requirement when in conflict.
6.2.6	Deploy Instance Lifecycle
Deployment of an Application differs only slightly depending on if it is a CNF, xApp, or rApp. Basically, the process of registering with a Run Time Environment is not required when the application is a CNF. The xApp and rApp differ in the registration process and the mechanisms to connect the Application with other Applications of the same type is dependent on the framework used.
The use case for CNF deployment is in clause 3.2.1 of the WG6 Orchestration Use Cases and Requirements for O-RAN Virtualized RAN [i.8]. The use case for xApp deployment is in clause 3.3.2 of the same document. An example use case for deployment of an rApp is in Annex C.5 of this document.
6.2.6.1	Functional Requirements
Annex A:	(Informative) Cardinality
This informative Annex provides background information regarding the cardinality of different O-RAN architecture elements.  It is not intended as a requirement on cardinality.
The RAN network has an expected hierarchical fan out. Therefore, the O-RAN sizing would be:
Non-RT RIC (1..j)
Near-RT RIC (1..k)
O-CU-CP (1..m)
O-CU-UP (1..n)
O-DU (1..p)
O-RU (1..q)
Where: 1<=j; j<=k; k<=m; m<=n; m<=p; p<=q
Due to resiliency and scaling aspects of cloud implementations an O-DU will logically be connected to one O-CU-CP. The O-CU-CP may in fact be a pool of O-CU-CP instances to handle loads.
O-CU-UP NFs will be pooled and aligned with the services they are configured to serve. The O-CU-CP will assign the O-CU-UP that an O-DU needs to connect to for a given UE session.
An O-DU may serve many O-RU NFs depending on its designed capacity to manage the loop 1 processing.
One Near-RT RIC will be connected to multiple O-CU-CP, O-CU-UP, and O-DU NFs. For resiliency the NFs may be connected to more than one Near-RT RIC, however, it shall not require duplication of data to be sent to each RIC instance.
A Near-RT RIC will be connected to one non-RT RIC.
Annex B:	Void
Annex C:	(Informative) Common App Lifecycle Flows
This clause provides examples of information flow during various lifecycle activities which are not depicted in other O-RAN Specifications.
C.1 Solution SW Package Lifecycle.
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
autonumber
Box “Personnel” #lightblue
Actor “Cloud\nNetwork\nApplication\nDeveloper\n(CNAD)” as CNAD
End box
Database “Application\nPackage” as PKG
== PACK ==
Loop foreach <color Blue>ConfigurationManagementDescriptionFile</color>
CNAD -> PKG : Add File to **<color Blue>Package</color>**
Note right CNAD : Update **<color Blue>ManagementDescriptor.ConfigurationDictionary</color>** with filename and filetype
End loop
Loop foreach **<color Blue>Certificate</color>**
CNAD -> PKG : Add File to **<color Blue>Package</color>**
Note right CNAD : Update **<color Blue>ManagementDescriptor.SecurityDescriptor.Certificate</color>** with filename
End loop
CNAD -> PKG : Add **<color Blue>Management Descriptor</color>**
Loop foreach Component of the App
CNAD -> PKG : Add **<color Blue>ExecutableImage</color>**
Note right CNAD : Update Component Descriptor with CloudNativeFileNames
Alt if rApp or xApp Component then
CNAD -> PKG : Add **<color Blue>RTE Descriptor</color>**
end
Note right CNAD : Update **<color Blue>ComponentDescriptor</color>** with **<color Blue>RTEDescriptorFileName</color>**
CNAD -> PKG : Add **<color Blue>Component Descriptor
end
ALT if ML Enabled
CNAD -> PKG : **<color Blue>ML Model Descriptor(s)</color>**
Alt If Training has been performed then
CNAD-> PKG : Add **<color Blue>ML Training History</color>**
end
End
Loop For each Deployment Option
Loop For each Deployment Module
CNAD -> PKG : add **<color Blue>CloudNative Descriptor</color>**
End
Note right CNAD : Update **<color Blue>Deployment Descriptor</color>** with **<color Blue>CloudNativeFileNames</color>**
CNAD -> PKG : Add **<color Blue>Deployment Descriptor</color>**
end
== SECURE ==
CNAD -> PKG : Add Checksum for artifacts
CNAD -> PKG : Sign Overall Package
@enduml
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
autonumber
Box “Personnel” #lightblue
Actor “Cloud\nNetwork\nApplication\nDeveloper\n(CNAD)” as CNAD
End box
Database “Application\nPackage” as PKG
== PACK ==
Loop foreach <color Blue>ConfigurationManagementDescriptionFile</color>
CNAD -> PKG : Add File to **<color Blue>Package</color>**
Note right CNAD : Update **<color Blue>AppDescriptor.ConfigurationDictionary</color>** with filename and filetype
End loop
Loop foreach **<color Blue>Certificate</color>**
CNAD -> PKG : Add File to **<color Blue>Package</color>**
Note right CNAD : Update **<color Blue>AppDescriptor.SecurityDescriptor.Certificate</color>** with filename
End loop
CNAD -> PKG : Add **<color Blue>App Descriptor</color>**
Loop foreach Component of the App
CNAD -> PKG : Add **<color Blue>DockerImage</color>**
Note right CNAD : Update Component Descriptor with CloudNativeFileNames
Alt if rAPP or xAPP Component then
CNAD -> PKG : Add **<color Blue>RTE Descriptor</color>**
end
Note right CNAD : Update **<color Blue>ComponentDescriptor</color>** with **<color Blue>RTEDescriptorFileName</color>**
CNAD -> PKG : Add **<color Blue>Component Descriptor
end
ALT if ML Enabled
CNAD -> PKG : **<color Blue>ML Model Descriptor(s)</color>**
Alt If Training has been performed then
CNAD-> PKG : Add **<color Blue>ML Training History</color>**
end
End
Loop For each Deployment Option
Loop For each Deployment Module
CNAD -> PKG : add **<color Blue>CloudNative Descriptor</color>**
End
Note right CNAD : Update **<color Blue>Deployment Descriptor</color>** with **<color Blue>CloudNativeFileNames</color>**
CNAD -> PKG : Add **<color Blue>Deployment Descriptor</color>**
end
== SECURE ==
CNAD -> PKG : Add Checksum for artifacts
CNAD -> PKG : Sign Overall Package
@enduml
C.2 Onboarded SW Package Lifecycle.
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
autonumber
Database “Application\nPackage” as PKG
Box “Personnel” #lightblue
Actor “Cloud\nNative\nApplication\nDeveloper\n(CNAD)” as CNAD
Actor “Service\nDesigner\n(SMO)” as SDO
End box
box “Service Management & \nOrchestration Framework” #gold
Participant “Import\nFunction” as SD
Database “Catalog” as CTLG
end box
== VERIFY ==
SDO -> PKG : Fetch
SDO -> SD : Onboard (**<color Blue>ApplicationPackage</color>**)
SD -> PKG : Authenticate Signature
Alt If Authentication Fails
SD  SDO : Terminate Processing and Indicate Authentication Failure
SDO -> CNAD : Send Feedback (fix request)
end
SD -> PKG : verify checksums
Alt If Verification Fails
SD  SDO : Terminate Processing and Indicate File Corruption
SDO -> CNAD : Send Feedback (fix request)
End
SD -> CTLG : Add Package to Catalogue
== UNPACK ==
Group Management Descriptor Processing
SD -> PKG : Get **<color Blue>Management Descriptor</color>**
Loop foreach **<color Blue>ConfigurationManagementDescriptionFile</color>** in **<color Blue>Management Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>Certificate</color>** in **<color Blue>Management Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>ExecutableImage</color>** in **<color Blue>Management Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>RTE Descriptor</color>** in **<color Blue>Management Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
SD -> CTLG : Catalogue **<color Blue>Management Descriptor</color>**
End
Group ML Mode Descriptor Processing
Loop Foreach **<color Blue>ML Model</color>** in **<color Blue>Application Package</color>**
SD -> PKG : **<color Blue>Get ML Model</color>**
SD -> CTLG : Catalogue **<color Blue>ML Model</color>**
End Loop
End
Group Deployment Descriptor Processing
SD -> PKG : Get **<color Blue>DeploymentDescriptor</color>**
Loop Foreach **<color Blue>CloudNativeDescriptorFile in **<color Blue>Application Package</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End Loop
SD -> CTLG : Catalogue **<color Blue>Deployment Descriptor</color>**
End
SD  SDO : Success: Package Catalogued.
@enduml
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
autonumber
Database “Application\nPackage” as PKG
Box “Personnel” #lightblue
Actor “Cloud\nNative\nApplication\nDeveloper\n(CNAD)” as CNAD
Actor “Service\nDesigner\n(SMO)” as SDO
End box
box “Service Management & \nOrchestration Framework” #gold
Participant “Import\nFunction” as SD
Database “Catalog” as CTLG
end box
== VERIFY ==
SDO -> PKG : Fetch
SDO -> SD : Onboard (**<color Blue>ApplicationPackage</color>**)
SD -> PKG : Authenticate Signature
Alt If Authentication Fails
SD  SDO : Terminate Processing and Indicate Authentication Failure
SDO -> CNAD : Send Feedback (fix request)
end
SD -> PKG : verify checksums
Alt If Verification Fails
SD  SDO : Terminate Processing and Indicate File Corruption
SDO -> CNAD : Send Feedback (fix request)
End
SD -> CTLG : Add Package to Catalogue
== UNPACK ==
Group App Descriptor Processing
SD -> PKG : Get **<color Blue>App Descriptor</color>**
Loop foreach **<color Blue>ConfigurationManagementDescriptionFile</color>** in **<color Blue>App Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>Certificate</color>** in **<color Blue>App Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>DockerImage</color>** in **<color Blue>App Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
Loop foreach **<color Blue>RTE Descriptor</color>** in **<color Blue>App Desciptor</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End loop
SD -> CTLG : Catalogue **<color Blue>App Descriptor</color>**
End
Group ML Mode Descriptor Processing
Loop Foreach **<color Blue>ML Model</color>** in **<color Blue>Application Package</color>**
SD -> PKG : **<color Blue>Get ML Model</color>**
SD -> CTLG : Catalogue **<color Blue>ML Model</color>**
End Loop
End
Group Deployment Descriptor Processing
SD -> PKG : Get **<color Blue>DeploymentDescriptor</color>**
Loop Foreach **<color Blue>CloudNativeDescriptorFile in **<color Blue>Application Package</color>**
SD -> PKG : Extract File
SD -> CTLG : Add File
Note Right SD : Update for local file names
End Loop
SD -> CTLG : Catalogue **<color Blue>Deployment Descriptor</color>**
End
SD  SDO : Success: Package Catalogued.
@enduml
C.3 Onboarded ManagementDescriptor Certification Lifecycle
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
autonumber
Box “Personnel” #lightblue
Actor “Cloud\nNetwork\nApplication\nDeveloper\n(CNAD)” as CNAD
Actor “Application\nTester\n(SMO)” as SDO
End box
box “Service Management & \nOrchestration Framework” #gold
Participant “Certification\nFunction” as SD
Participant “Service\nPlanning” as SVP
Database “Catalogue” as CTLG
Database “Run Time Library” as RTL
end box
== CERTIFY ==
SDO -> SD : Begin Testing
Loop While Certification In Progress
SD -> SD :
Note Right : Perform Certification Testing
== CATALOG CHANGES ==
Alt If Certification Fails due to Configuration then
SD -> CTLG : Update Configuration Data for next Validation Iteration
Note right SDO #Yellow
<color red> The Initial recommended Configuration From the Package is not defined in the information model </color>
End note
End if
End loop
== PUBLISH ==
Alt If Certification Succeeds then
SD -> CTLG : Fetch App Catalog Data
SD -> RTL : Publish App Catalog Data to Run Time Library
SD -> SDO : Certifaction Complete
Else Certification Failed Due to Defect then
SD  SDO : Certifaction Failed (defect)
SDO -> CNAD : Feedback (fix requests)
Else Certification Failed Due to Training then
SD -> SVP : Send to AI/ML Training
SD  SDO : Certifaction Failed (training)
…
SVP -> SD : AI/ML Training Completed
SD -> CTLG : Establish New App Version to be Certified
SD -> CTLG : Update Training Record
Else Other Failure Detected
SD  SDO : Certifaction Failed (failure)
end
@enduml
C.4 Application Training Lifecycle.
C.5 Deploy rApp Instance Lifecycle.
@startuml
skinparam sequenceArrowThickness 2
skinparam ParticipantPadding 5
skinparam BoxPadding 10
skinparam sequenceArrowColor green
autonumber
Box “Personnel” #lightblue
Actor “Operations\nPersonnel” as OPS
End box
box “Service Management & \nOrchestration Framework” #gold
Database “Run Time Library” as RTL
Participant “Network\nFunction\nOrchestrator” as NFO
Participant “Network\nFunction\nManager” as NFM
Participant “Non-RT\nRIC” as NrtRIC
Participant “rApp” as rApp
end box
Box “O-Cloud Platform” #lightseagreen
participant DMS
End box
Box “O-RAN” #lightpink
Participant “RAN NF” as CNF
end box
OPS –> RTL : Get **<color Blue> Deployment Options</color>**
OPS –> OPS :
Note right
Determine Runtime Variables for each **<color Blue>DeploymentItem.
This includes the initial rApp config. Post deployment
the xApp is configured through the Non-RT RIC via R1.
End note
OPS -> NFO : Deployment Request (selectedOption)
NFO –> RTL : Get **<color Blue>DeplymentItem</color>** for Selected Option
NFO -> NFO : Decompose and determine sequence
Note over NFO, rApp
The SMO determines the correct sequence for deploying the rApps
End note
Loop for each rApp to be deployed
NFO-> NFO : Determine homing
Note over NFO, rApp
The SMO determines on which Non-RT RIC/O-Cloud to deploy this/these xApp(s).
This can be explicitly identified by the Operations Personnel or via homing policies
End note
Group rApp Deploy
Loop Foreach **<color Blue>DeploymentItem</color>**
NFO –> RTL : Get **<color Blue>CloudNativeDescriptor</color>** for **<color Blue> DeploymentItem </color>**
NFO -> DMS : <<O2>> Create Workload (DeploymentItem, RuntimeVariables)
DMS -> rApp ** : create
DMS  NFO : notify deployment instantiation is completed (DeploymentID)
NFO -> NFO :
Note right
Once complete, SMO updates
its rApp inventory record with
the Deployment ID from the O-Cloud
End note
End loop
rApp -> NrtRIC : <<R1>> Register (**<color Blue>RTE Descriptor</color>**)
opt if rApp is requesting O1 or SMO data then
NrtRIC -> NFM : Request SMO data
NFM -> NFM : Evaluate Request
opt if new NmS data is required then
NFM -> NFM : translate requirements to PM request (new/update)
NFM -> CNF : <<O1>> PM Job Changes
End if
end
End
End loop
NFO  OPS : rApp Deployment status (Success)
@enduml
Annex ZZZ:	Void
History